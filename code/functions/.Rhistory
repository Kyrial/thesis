whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
######################
#3.2 BIG FUNCTION
######################
kfold_gini <- function(bdd, weight, metric, layer, regularization, print_number) {
print('######')
print(layer)
######################
# 3.2.1 DATA MANAGEMENT
######################
labels_path = paste('../../data/redesigned/',bdd,'/labels_',bdd,'.csv', sep="")
log_path =paste('../../results/',bdd,'/pca/', sep="")
log_path_rate =paste('../../results/',bdd,'/log_', sep="")
#chargement du fichier
df_pc = read_csv(file = paste(log_path,"pca_values_",layer,".csv", sep =""), show_col_types = FALSE)
df_pc = df_pc[,-1]
#on récupère les notes de beauté
matrix_metrics <- do.call(cbind, fromJSON(file = paste(log_path_rate,'_',bdd,'_',weight,'_',metric,'_','_BRUTMETRICS','.csv',sep=""),simplify = FALSE))
df_metrics <- as.data.frame(matrix_metrics, optional = TRUE)
df_metrics = sapply(df_metrics, as.numeric)
df_metrics <- as.data.frame(df_metrics)
df = cbind(df_metrics$rate, df_pc)
df <- plyr::rename(df, c("df_metrics$rate" = "rate"))
###########################################################
#3.2.2Itérations sur les différents seuils de variance expliquée
############################################################
#chargement du fichier de somme cumulée de variance expliquée par composante
log_variance =paste('../../results/',bdd,'/pca_variance/', sep="")
df_variance = read_csv(file = paste(log_variance,"varianceCumule_",layer,".csv", sep =""), show_col_types = TRUE)
df_variance = df_variance[,-1]
#définition des seuils, en %
variances = c(80) #c(20,30,40,50,60,70,80)
var_tresholds = c()
#création d'un vecteur contenant l'indice de la dernière variable pour chaque seuil
for (variance in variances) {
var_treshold = which(df_variance[1,] <= variance, arr.ind = F)
var_treshold = tail(var_treshold, n=1)
var_tresholds = c(var_tresholds,var_treshold)
}
AICs = c()
BICs = c()
R_squareds = c()
all_models = c()
for (treshold in var_tresholds) {
###############################
# 3.2.3. MODEL: REGRESSION WITH REGULARIZATION (ridge, lasso or elasticnet)
###############################
treshold = treshold + 1 #pour prendre en compte la colonne "rate"
print('####TRESHOLD:')
print(treshold)
temp_df = df[,1:treshold]
ctrl = trainControl(method = "repeatedcv", number = 10) #10-fold cv
model1 = train( rate ~ ., data = temp_df ,method = regularization,preProc = c("center", "scale"),trControl = ctrl, metric = "Rsquared")
alpha = model1$results$alpha[1]
lambda = model1$results$lambda[1]
r_squared = model1$results$Rsquared[1]
matrix = as.matrix(temp_df)
x = matrix[,-1]
y = matrix[,1]
if (regularization == 'glmnet'){
model2 = cv.glmnet(x, y, alpha = alpha)
} else if (regularization == 'lasso'){
model2 = cv.glmnet(x, y, alpha = 1)
} else { #cad regularization = ridge
model2 = cv.glmnet(x, y, alpha = 0)
}
coefs = coef(model2)
print(" ## number of nonzero coefficients : ")
print(length(coefs@x))
print("percentage of non 0 coefficients:")
print((length(coefs@x)/treshold)*100)
criterions =  glmnet_cv_aicc(model2, lambda =  'lambda.min')
AICs = c(AICs, criterions$AICc)
BICs = c(BICs, criterions$BIC)
R_squareds = c(R_squareds, r_squared)
}
list = list('r_squareds' = R_squareds, 'AIC'= AICs, 'BIC'= BICs)
return(list)
}
#####################################################################################
# 4. PARAMETERS:
#####################################################################################
bdd <- c('CFD')
weight <- c('imagenet')
metric <- c('gini_flatten')
layers <-  c( 'block1_conv1','block1_conv2',
'block2_conv1','block2_conv2',
'block3_conv1','block3_conv2','block3_conv3',
'block4_conv1','block4_conv2','block4_conv3',
'block5_conv1','block5_conv2','block5_conv3'
)
regularization <- 'lasso' #ridge for ridge, lasso for lasso, glmnet for elasticnet
print_number = 200
set.seed(123)
######################################################################################
# 5. MAIN:
######################################################################################
R_squareds = c()
AICs = c()
BICs = c()
vector_tresholds = c()
models = c()
######################
#5.1 Loop on kfold_gini's function for each layer
######################
for (layer in layers){
results = kfold_gini(bdd, weight, metric, layer, regularization, print_number)
R_squareds = c(R_squareds, results$r_squareds)
AICs = c(AICs, results$AIC)
BICs = c(BICs, results$BIC)
}
#####################################################################################
# 1. DESCRIPTION:
#####################################################################################
#####################################################################################
# 2. LIBRAIRIES:
#####################################################################################
library("rjson")
library("readr")
library("purrr")
library("tidyr")
library("tibble")
library("plyr")
library("corrplot")
library("FactoMineR")
library("dplyr")
library("caret")
library("jtools")
library("broom.mixed")
library("glmnet")
library("tidyverse")
setwd("/home/renoult/Bureau/thesis/code/functions")
#####################################################################################
# 3. Fonctions
#####################################################################################
######################
#3.1 AIC/BIC
######################
glmnet_cv_aicc <- function(fit, lambda = 'lambda.1se'){
whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
#####################################################################################
# 4. PARAMETERS:
#####################################################################################
bdd <- c('CFD')
weight <- c('imagenet')
metric <- c('gini_flatten')
layers <-   c('input_1',
'block1_conv1','block1_conv2','block1_pool',
'block2_conv1','block2_conv2','block2_pool',
'block3_conv1','block3_conv2','block3_conv3','block3_pool',
'block4_conv1','block4_conv2','block4_conv3','block4_pool',
'block5_conv1','block5_conv2','block5_conv3','block5_pool',
'fc1','fc2',
'flatten')
layer = 'block3_conv2'
regularization <- 'lasso' #0 for ridge, 1 for lasso
print_number = 200
set.seed(123)
######################
#3.2 model (fonction dans l'autre code)
######################
print('######')
print(layer)
######################
# 3.2.1 DATA MANAGEMENT
######################
labels_path = paste('../../data/redesigned/',bdd,'/labels_',bdd,'.csv', sep="")
log_path =paste('../../results/',bdd,'/pca/', sep="")
log_path_rate =paste('../../results/',bdd,'/log_', sep="")
#chargement du fichier
df_pc = read_csv(file = paste(log_path,"pca_values_",layer,".csv", sep =""), show_col_types = FALSE)
df_pc = df_pc[,-1]
#on récupère les notes de beauté
matrix_metrics <- do.call(cbind, fromJSON(file = paste(log_path_rate,'_',bdd,'_',weight,'_',metric,'_','_BRUTMETRICS','.csv',sep=""),simplify = FALSE))
df_metrics <- as.data.frame(matrix_metrics, optional = TRUE)
df_metrics = sapply(df_metrics, as.numeric)
df_metrics <- as.data.frame(df_metrics)
df = cbind(df_metrics$rate, df_pc)
df <- plyr::rename(df, c("df_metrics$rate" = "rate"))
###############################
# 3.2.2. MODEL: REGRESSION WITH REGULARIZATION (ridge, lasso or elasticnet)
###############################
ctrl = trainControl(method = "repeatedcv", number = 10) #10-fold cv
model1 = train( rate ~ ., data = df ,method = regularization,preProc = c("center", "scale"),trControl = ctrl, metric = "Rsquared")
alpha = model1$results$alpha[1]
lambda = model1$results$lambda[1]
r_squared = model1$results$Rsquared[1]
matrix = as.matrix(df)
x = matrix[,-1]
y = matrix[,1]
if (regularization == 'glmnet'){
model2 = cv.glmnet(x, y, alpha = alpha)
} else if (regularization == 'lasso'){
model2 = cv.glmnet(x, y, alpha = 1)
} else { #cad regularization = ridge
model2 = cv.glmnet(x, y, alpha = 1)
}
criterions =  glmnet_cv_aicc(model2)
list = list('r_squared' = r_squared, 'AIC'= criterions$AICc, 'BIC'= criterions$BIC )
coefs = coef(model2)
length(coefs@x)
print(coefs)
#####################################################################################
# 2. LIBRAIRIES:
#####################################################################################
library("rjson")
library("readr")
library("purrr")
library("tidyr")
library("tibble")
library("plyr")
library("corrplot")
library("FactoMineR")
library("dplyr")
library("caret")
library("jtools")
library("broom.mixed")
library("glmnet")
library("tidyverse")
library("tibble")
setwd("/home/renoult/Bureau/thesis/code/functions")
#####################################################################################
# 3. Fonctions
#####################################################################################
######################
#3.1 AIC/BIC
######################
glmnet_cv_aicc <- function(fit, lambda = 'lambda.1se'){
whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
######################
#3.2 BIG FUNCTION
######################
kfold_gini <- function(bdd, weight, metric, layer, regularization, print_number) {
print('######')
print(layer)
######################
# 3.2.1 DATA MANAGEMENT
######################
labels_path = paste('../../data/redesigned/',bdd,'/labels_',bdd,'.csv', sep="")
log_path =paste('../../results/',bdd,'/pca/', sep="")
log_path_rate =paste('../../results/',bdd,'/log_', sep="")
#chargement du fichier
df_pc = read_csv(file = paste(log_path,"pca_values_",layer,".csv", sep =""), show_col_types = FALSE)
df_pc = df_pc[,-1]
#on récupère les notes de beauté
matrix_metrics <- do.call(cbind, fromJSON(file = paste(log_path_rate,'_',bdd,'_',weight,'_',metric,'_','_BRUTMETRICS','.csv',sep=""),simplify = FALSE))
df_metrics <- as.data.frame(matrix_metrics, optional = TRUE)
df_metrics = sapply(df_metrics, as.numeric)
df_metrics <- as.data.frame(df_metrics)
df = cbind(df_metrics$rate, df_pc)
df <- plyr::rename(df, c("df_metrics$rate" = "rate"))
###########################################################
#3.2.2Itérations sur les différents seuils de variance expliquée
############################################################
#chargement du fichier de somme cumulée de variance expliquée par composante
log_variance =paste('../../results/',bdd,'/pca_variance/', sep="")
df_variance = read_csv(file = paste(log_variance,"varianceCumule_",layer,".csv", sep =""), show_col_types = TRUE)
df_variance = df_variance[,-1]
#définition des seuils, en %
variances = c(80) #c(20,30,40,50,60,70,80)
var_tresholds = c()
#création d'un vecteur contenant l'indice de la dernière variable pour chaque seuil
for (variance in variances) {
var_treshold = which(df_variance[1,] <= variance, arr.ind = F)
var_treshold = tail(var_treshold, n=1)
var_tresholds = c(var_tresholds,var_treshold)
}
AICs = c()
BICs = c()
R_squareds = c()
all_models = c()
for (treshold in var_tresholds) {
###############################
# 3.2.3. MODEL: REGRESSION WITH REGULARIZATION (ridge, lasso or elasticnet)
###############################
treshold = treshold + 1 #pour prendre en compte la colonne "rate"
print('####TRESHOLD:')
print(treshold)
temp_df = df[,1:treshold]
ctrl = trainControl(method = "repeatedcv", number = 10) #10-fold cv
model1 = train( rate ~ ., data = temp_df ,method = regularization,preProc = c("center", "scale"),trControl = ctrl, metric = "Rsquared")
alpha = model1$results$alpha[1]
lambda = model1$results$lambda[1]
r_squared = model1$results$Rsquared[1]
matrix = as.matrix(temp_df)
x = matrix[,-1]
y = matrix[,1]
if (regularization == 'glmnet'){
model2 = cv.glmnet(x, y, alpha = alpha)
} else if (regularization == 'lasso'){
model2 = cv.glmnet(x, y, alpha = 1)
} else { #cad regularization = ridge
model2 = cv.glmnet(x, y, alpha = 0)
}
coefs = coef(model2)
print(" ## number of nonzero coefficients : ")
print(length(coefs@x))
print("percentage of non 0 coefficients:")
print((length(coefs@x)/treshold)*100)
criterions =  glmnet_cv_aicc(model2, lambda =  'lambda.min')
AICs = c(AICs, criterions$AICc)
BICs = c(BICs, criterions$BIC)
R_squareds = c(R_squareds, r_squared)
}
list = list('r_squareds' = R_squareds, 'AIC'= AICs, 'BIC'= BICs)
return(list)
}
#####################################################################################
# 4. PARAMETERS:
#####################################################################################
bdd <- c('JEN')
weight <- c('imagenet')
metric <- c('gini_flatten')
layers <-  c( 'block1_conv1','block1_conv2',
'block2_conv1','block2_conv2',
'block3_conv1','block3_conv2','block3_conv3',
'block4_conv1','block4_conv2','block4_conv3',
'block5_conv1','block5_conv2','block5_conv3'
)
regularization <- 'lasso' #ridge for ridge, lasso for lasso, glmnet for elasticnet
print_number = 200
set.seed(123)
######################################################################################
# 5. MAIN:
######################################################################################
R_squareds = c()
AICs = c()
BICs = c()
vector_tresholds = c()
models = c()
######################
#5.1 Loop on kfold_gini's function for each layer
######################
for (layer in layers){
results = kfold_gini(bdd, weight, metric, layer, regularization, print_number)
R_squareds = c(R_squareds, results$r_squareds)
AICs = c(AICs, results$AIC)
BICs = c(BICs, results$BIC)
}
#####################################################################################
# 2. LIBRAIRIES:
#####################################################################################
library("rjson")
library("readr")
library("purrr")
library("tidyr")
library("tibble")
library("plyr")
library("corrplot")
library("FactoMineR")
library("dplyr")
library("caret")
library("jtools")
library("broom.mixed")
library("glmnet")
library("tidyverse")
library("tibble")
setwd("/home/renoult/Bureau/thesis/code/functions")
#####################################################################################
# 3. Fonctions
#####################################################################################
######################
#3.1 AIC/BIC
######################
glmnet_cv_aicc <- function(fit, lambda = 'lambda.1se'){
whlm <- which(fit$lambda == fit[[lambda]])
with(fit$glmnet.fit,
{
tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
k <- df[whlm]
n <- nobs
return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
'BIC' = log(n) * k - tLL))
})
}
######################
#3.2 BIG FUNCTION
######################
kfold_gini <- function(bdd, weight, metric, layer, regularization, print_number) {
print('######')
print(layer)
######################
# 3.2.1 DATA MANAGEMENT
######################
labels_path = paste('../../data/redesigned/',bdd,'/labels_',bdd,'.csv', sep="")
log_path =paste('../../results/',bdd,'/pca/', sep="")
log_path_rate =paste('../../results/',bdd,'/log_', sep="")
#chargement du fichier
df_pc = read_csv(file = paste(log_path,"pca_values_",layer,".csv", sep =""), show_col_types = FALSE)
df_pc = df_pc[,-1]
#on récupère les notes de beauté
matrix_metrics <- do.call(cbind, fromJSON(file = paste(log_path_rate,'_',bdd,'_',weight,'_',metric,'_','_BRUTMETRICS','.csv',sep=""),simplify = FALSE))
df_metrics <- as.data.frame(matrix_metrics, optional = TRUE)
df_metrics = sapply(df_metrics, as.numeric)
df_metrics <- as.data.frame(df_metrics)
df = cbind(df_metrics$rate, df_pc)
df <- plyr::rename(df, c("df_metrics$rate" = "rate"))
###########################################################
#3.2.2Itérations sur les différents seuils de variance expliquée
############################################################
#chargement du fichier de somme cumulée de variance expliquée par composante
log_variance =paste('../../results/',bdd,'/pca_variance/', sep="")
df_variance = read_csv(file = paste(log_variance,"varianceCumule_",layer,".csv", sep =""), show_col_types = TRUE)
df_variance = df_variance[,-1]
#définition des seuils, en %
variances = c(30) #c(20,30,40,50,60,70,80)
var_tresholds = c()
#création d'un vecteur contenant l'indice de la dernière variable pour chaque seuil
for (variance in variances) {
var_treshold = which(df_variance[1,] <= variance, arr.ind = F)
var_treshold = tail(var_treshold, n=1)
var_tresholds = c(var_tresholds,var_treshold)
}
AICs = c()
BICs = c()
R_squareds = c()
all_models = c()
for (treshold in var_tresholds) {
###############################
# 3.2.3. MODEL: REGRESSION WITH REGULARIZATION (ridge, lasso or elasticnet)
###############################
treshold = treshold + 1 #pour prendre en compte la colonne "rate"
print('####TRESHOLD:')
print(treshold)
temp_df = df[,1:treshold]
ctrl = trainControl(method = "repeatedcv", number = 10) #10-fold cv
model1 = train( rate ~ ., data = temp_df ,method = regularization,preProc = c("center", "scale"),trControl = ctrl, metric = "Rsquared")
alpha = model1$results$alpha[1]
lambda = model1$results$lambda[1]
r_squared = model1$results$Rsquared[1]
matrix = as.matrix(temp_df)
x = matrix[,-1]
y = matrix[,1]
if (regularization == 'glmnet'){
model2 = cv.glmnet(x, y, alpha = alpha)
} else if (regularization == 'lasso'){
model2 = cv.glmnet(x, y, alpha = 1)
} else { #cad regularization = ridge
model2 = cv.glmnet(x, y, alpha = 0)
}
coefs = coef(model2)
print(" ## number of nonzero coefficients : ")
print(length(coefs@x))
print("percentage of non 0 coefficients:")
print((length(coefs@x)/treshold)*100)
criterions =  glmnet_cv_aicc(model2, lambda =  'lambda.min')
AICs = c(AICs, criterions$AICc)
BICs = c(BICs, criterions$BIC)
R_squareds = c(R_squareds, r_squared)
}
list = list('r_squareds' = R_squareds, 'AIC'= AICs, 'BIC'= BICs)
return(list)
}
#####################################################################################
# 4. PARAMETERS:
#####################################################################################
bdd <- c('CFD')
weight <- c('imagenet')
metric <- c('gini_flatten')
layers <-  c( 'block1_conv1','block1_conv2',
'block2_conv1','block2_conv2',
'block3_conv1','block3_conv2','block3_conv3',
'block4_conv1','block4_conv2','block4_conv3',
'block5_conv1','block5_conv2','block5_conv3'
)
regularization <- 'lasso' #ridge for ridge, lasso for lasso, glmnet for elasticnet
print_number = 200
set.seed(123)
######################################################################################
# 5. MAIN:
######################################################################################
R_squareds = c()
AICs = c()
BICs = c()
vector_tresholds = c()
models = c()
######################
#5.1 Loop on kfold_gini's function for each layer
######################
for (layer in layers){
results = kfold_gini(bdd, weight, metric, layer, regularization, print_number)
R_squareds = c(R_squareds, results$r_squareds)
AICs = c(AICs, results$AIC)
BICs = c(BICs, results$BIC)
}
